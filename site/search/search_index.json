{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AVDASI 2 docs","text":"<p>Welcome to the offical documentation for the University of Bristol's Aerospace Vehicular Design and Systems Integration 2 course.</p> <p>This site contains general documentation for the AVDASI 2 course.</p> <p>It's hosted on the AVDASI 2 GitHub org, and uses MkDocs auto-compiled via a GitHub Action. Code from the AVDASI 2 Example_Code repo is also auto-synced to the docs using GitHub Action so code snippets can be displayed and will update after every new push. AVDASI 2 members can push changes to the docs which will be approved by an owner and published. If you want to trial stuff locally first just clone the repo and do:</p> <pre><code>pip install mkdocs-material mkdocs-implicit-index\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000.</p>"},{"location":"#navigation-structure","title":"Navigation structure","text":"<p>This MkDocs is configured to use mkdocs-literate-nav to pull nav and page ordering from a list in index.md within each folder, like this:</p> <ul> <li>Avionics</li> <li>Aerodynamics</li> <li>Structures</li> </ul>"},{"location":"Aerodynamics/","title":"Aerodynamics","text":"<p>Example homeage</p>"},{"location":"Avionics/","title":"Avionics Guidelines","text":"<p>The goal of this section is to lay out a minimum viable product for the avionics portion of the AVDASI 2 course. Hopefully a clear baseline is established for a test-ready avionics system.</p> <p>Most links are to external open-source resources from which you should be able to get creative and implement creative solutions to fulfill the requirements of the course.</p> <p>When in doubt consult the ardupilot.org website.</p> <p>The docs will walk you through all the necessary subcomponents of your Avionics system.</p> <p>The Cube is your main flight computer, you will be guided on how to plug it in and what all its gadgets do. </p> <p>Mission Planner is a software that lets you do your initial setup, you'll be shown how to connect to the cube, configure parameters, and set up servos. </p> <p>PyMAVLink is the communication protocol used in your custom GCS. </p> <p>The Wifi and RC sections show you how to set up the necessary telemtry systems. </p> <p>I2C &amp; LUA section gives you a quick runthrough on how to write onboard code for the Cube and set up sensor communication. </p> <p>Data Logging is a vital component of your system, necesarry for the other subteams in your company that rely on the test results, you'll be shown various ways to store, extract, and postprocess data from the Cube.</p> <p>The example code section is a series of scripts written to demonstrate a minimum viable ground station, carefully crafted by master coders for you to use as a basis for your own development.</p> <ul> <li>Cube Information</li> <li>Mission Planner</li> <li>PyMAVLink</li> <li>Wifi</li> <li>RC</li> <li>I2C &amp; LUA</li> <li>Data Logging</li> <li>Example Code</li> <li>Pressure Sensor PDF</li> </ul>"},{"location":"Avionics/Cube-Information/","title":"Cube Information","text":"<p>The Cube Orange+ is a high-performance open-source flight controller designed for professional UAVs and robotics. It simplifies integration with ArduPilot, featuring built-in telemetry ports and onboard SD card logging for mission data.</p> <p>You will have the unique opportunity to play with one as the Cube will act as your main flight computer.</p> <p> </p> <p>Image Credit: Ardupilot</p> <p>The cube is a very expensive research grade flight computer so please don\u2019t blow it up</p> <p>Always use the buzzer adapter when connecting over USB and the stop button when using the power source.  </p> <p>Never plug directly into USB.  </p> <p>Unplug if you see voltage/current spikes or if the buzzer starts making noise.  </p> <p>If you see blue smoke, it's too late.</p> <p>Cube User Manual (cubepilot.org)</p> <p>Servo Movement documentation (ardupilot.org)</p> <p>MAVLink common messages (mavlink.io)</p>"},{"location":"Avionics/Cube-Information/#requirements","title":"Requirements","text":"<p>Year on year the requirements may vary but the basic bits stay the same. Make sure the check the Design Specification and Deliverables documents for specifics.</p> <p>The student-built avionics should be able to:</p> <ul> <li>Move the control surfaces</li> <li>Talk to the cube via Wifi</li> <li>Talk to the cube via Radio</li> <li>Log the generated data</li> <li>Sense flap angle</li> <li>Sense pressure</li> <li>Switch between cube modes and arming states</li> </ul>"},{"location":"Avionics/Cube-Information/#cube-setup","title":"Cube Setup","text":"Port What to plug in Power 1 Power plug USB USB dongle Telem 1 Wifi chip RC in RC transmitter AUX OUT 1 Power pin MAIN OUT 1-8 Servo pins I2C 2 I2C sensor <p>Add image of full system.</p>"},{"location":"Avionics/Data-Logging/","title":"Data Logging","text":""},{"location":"Avionics/Data-Logging/#downloading-cube-logs","title":"Downloading Cube logs","text":"<p>The flight controller automatically creates a log of all its sensors (IMUs, temp. sensors, etc.) and its attitude changes during operation into a .bin file. These are necessary to analyse the behaviour of the drone in the wind tunnel and should be downloaded after each test so that the appropriate subteams of the Company can use their data.</p> <p>The cube must be armed in order to log data</p> <p>The data in stored in .bin files. The easiest way to access these files is pulling them directly off of the SD card.</p> <p>These logs can also be accessed through Mission Planner by clicking the <code>Download DataFlash Log Via Mavlink</code> button in the <code>DataFlash Logs</code> panel.</p> <p>You can also view a selected .bin file directly with the <code>Review a Log</code> button</p> <p></p> <p>This open up the <code>Log Downloader</code> menu, showing all avaible log files which you can download from here.</p> <p></p> <p>The download is quite slow over usb connection and extremely slow over Wifi</p>"},{"location":"Avionics/Data-Logging/#optional-logging-through-lua-scripts","title":"Optional: Logging through LUA scripts","text":"<p>LUA scripts can create and modify files on the Cube\u2019s memory; therefore, it is possible to create logs using LUA scripts (i.e. saving flap angles from the sensor into a CSV). This should only be done for a few sensors only, as it requires a lot of processing power from the flight controller. The example scripts will showcase this as well.</p>"},{"location":"Avionics/Data-Logging/#matlab-data-analysis","title":"MatLab data analysis","text":"<p>A useful tool to analyse the Cube logs is the <code>Flight Log Analyser</code> app built into MatLab.</p> <p>To access the app you first need to download MatLab's <code>UAV Toolbox</code> extension from the Add-on Explorer.</p> <p></p> <p>After opening the <code>Flight Lob Analyser</code> app. Click import to import your .bin file previosuly downloaded using a method from Downloading Cube logs.</p> <p></p> <p>It may take a while for large .bin files to load</p> <p>The next step is is adding the desired signals you want to analyse. This is done by clicking the <code>Add Custom Signal</code> button. This will open the <code>Add Custom Signal</code> menu with a list of all the signals that the cube logged. </p> <p>The most relevant signal is <code>ATT</code></p> <p>This stands for \"Attitude\" which will give you the pitch/roll/yaw and other relevant data. </p> <p>Make sure to inclue the <code>TimeUS</code> signal since this will give you timestamps.</p> <p>Once you've selected your signals, click <code>Add Signals</code> and they'll appear in the <code>Signal Preview</code> box. </p> <p>You must name your signal before it lets you click <code>OK</code></p> <p></p> <p>Feel free to explore the other available signals</p> <p>Lots of cool post-processing can be done!</p> <p>Next click the <code>Add Figure</code> button to create a Figure. In the <code>PLOTS</code> dropdown menu, the <code>XY</code> custom plot is the most useful. Click on it to create a plot.</p> <p></p> <p>Finally, to plot signals into your figure, click the <code>Add Signal</code> button. A new line should appear. Double clicking on either the X or Y axis box in the table will open up the <code>Signal Browser</code> menu where you can select one of your previously added custom signals.</p> <p></p> <p>The image below shows the final result of the Pitch and Desired Pitch vs Time for a Fuselage test switching between the Cube's <code>Manual</code> and <code>Stabilize</code> mode and messing with the PD variables.</p> <p></p>"},{"location":"Avionics/Example-code/","title":"Example Code","text":"<p>A series of scripts were written to show a minimum viable ground station. Keep in mind your code will need to be better than this, you can\u2019t just copy it and hope for the best. It does provide a baseline to build off of and an example of how to meet the basic functionality needed.</p> <p>Each script should be able to be executed individually but Main.py allows you to execute them all simultaneously. You don\u2019t need to take your approach in your own GS but this is good since you can debug each function independently.</p> <p>All these scripts are stored in the avdasi2-avionics-demo GitHub repository and can be accessed there.</p> <p>You can clone that repository to start your own code.</p>"},{"location":"Avionics/Example-code/#mainpy","title":"Main.py","text":"<p>Links all the scripts together. Call each script as a function after defining them up top.</p> main.py"},{"location":"Avionics/Example-code/#gs-py","title":"GS.py","text":"<p>This script is what connects the cube to your ground station. It creates the connection, waits for a heartbeat, and after heartbeat is received it listens and prints messages. There\u2019s a wide range of messages and statuses you can listen for from the cube, some more useful than others, so up to you to figure out which ones you want. It also notifies you if the heartbeat is interrupted.</p> GS.py"},{"location":"Avionics/Example-code/#arm-py","title":"Arm.py","text":"<p>This script allows you to arm/disarm the cube and toggle its safety switch. Arming allows logging and the safety switch locks all servo movement. </p> Arm.py"},{"location":"Avionics/Example-code/#servopy","title":"Servo.py","text":"<p>This script actuates the movement of a servo. You\u2019ll have to edit it to allow multiple servos moving simultaneously. </p> Servo.py"},{"location":"Avionics/Example-code/#uipy","title":"UI.py","text":"<p>This script is a barebones user interface for a GCS. It uses tkinter python module. This was used for its simplicity but you can use whatever module or language you want (there\u2019s some that can make really nice looking UIs). The UI calls functions from the previous arming and servo controller scripts and maps them to buttons. It also allows you to input a specific servo angle and move the servo accordingly.</p> UI.py"},{"location":"Avionics/Example-code/#I2C-lua","title":"I2C.lua","text":"<p>This script gives an overview on how to write onboard code in LUA for the Cube and how to communicate using the I2C protocol.</p> I2C.lua"},{"location":"Avionics/Example-code/#mode-switchlua","title":"Mode-Switch.lua","text":"Mode-Switch.lua"},{"location":"Avionics/I2C%26LUA/","title":"I2C &amp; LUA","text":"<p>The Cube supports I2C communication, allowing you to connect a wide range of external sensors like airspeed sensors, magnetometers, and rangefinders using a shared two-wire interface. I\u00b22 devices must be correctly addressed and powered, with care taken to avoid address conflicts. </p> <p>I2C (Inter-Integrated Circuit) is a two-wire communication protocol that allows multiple digital devices to communicate over a shared bus.</p> <p>It\u2019s useful because it reduces wiring complexity and enables efficient communication between sensors, microcontrollers, and other peripherals.</p> <p>The Cube also supports Lua scripting (via ArduPilot), enabling onboard automation such as custom failsafes, LED behavior, telemetry filtering, or mission logic without requiring firmware modification. Lua is a lightweight, high-level scripting language designed for embedded systems, making it ideal for writing custom logic directly on the Cube.</p> <p>Don't be scared of LUA!</p> <p>Its a strange programming language but needs to be used as its the only way to write onboard code for the Cube.</p> <p>You'll get used to it don't worry.</p> <p>Ardupilot specific LUA documentation: LUA docs (github.com/ArduPilot)</p> <p>Ardupilot scripting support page: Common LUA scripts (ardupilot.com)</p> <p>I2C documentation: I2C-bus specification and user manual (nxp.com)</p> <p>This part of the document will provide basic information on how to set up I2C from both the hardware (wiring) and software side (through LUA scripts; see I2C.lua for further help).</p>"},{"location":"Avionics/I2C%26LUA/#wiring-of-the-i2c-bus","title":"Wiring of the I2C bus","text":"<p>An I2C serial bus uses two wires (not counting VCC and neutral): SCL \u2013 clock &amp; SDA \u2013 data. Being a multi-master/multi-slave, half-duplex protocol, multiple controllers and devices can be connected to the same bus, but only one can transmit at a time.</p> <p>The wiring of the serial bus itself is straightforward: connect the SCL line to the SCL pins and the SDA line to the SDA pins of all devices on the bus, as seen in Figure 1. It is very important, however, that both the SDA and SCL lines require pull-up resistors connected to the logical high voltage of the selected microcontroller that will pull the line high when needed. There is a complex way of sizing the resistance of these resistors with high and low resistances both having pros and cons, but generally 4.7 k\u2126 is perfectly suitable for this kind of application. </p> <p>If the Cube is directly used as the master, then there is no need for dedicated external pull-up resistors as there are built-in ones in the flight controller.</p> <p> Mock-up of an I2C serial bus. Image credit: https://learn.sparkfun.com/tutorials/i2c/all </p>"},{"location":"Avionics/I2C%26LUA/#enabling-scirpting-on-the-cubepilot","title":"Enabling scirpting on the CubePilot","text":"<p>Before LUA scripts can be executed onboard the flight controller, the scripting feature must be enabled using the parameters of the Cube. Using Mission Planner (or any other similar GS program), locate the <code>SCR_ENABLE</code> parameter and set it to <code>1</code> before rebooting the Cube. A new folder should appear in the <code>APM</code> folder named <code>scripts</code>; if it doesn\u2019t, it needs to be manually created.</p> <p>After this is done, any LUA code uploaded into this folder will be automatically executed when the Cube powered on.</p>"},{"location":"Avionics/I2C%26LUA/#setting-up-and-using-i2c-with-lua-scripts","title":"Setting up and using I2C with LUA scripts","text":"<p>This part tries to explain the basic process of setting up and reading data from an I2C bus. To help understanding, example codes are provided.</p> <p>The first thing that must be done when working with I2C is to take note of the address of the device that is to be used. To set up a device on the I2C bus, LUA\u2019s built-in i2c: module is used. For example, the following line  <pre><code>local sensor = i2c:get_device(bus, ADDR)\n</code></pre> will create a variable named sensor as an I2C device on bus <code>bus</code> (most likely will be <code>0</code> on the Cube) and with I2C address <code>ADDR</code>.</p> <p>To read data from a specific register from a device the <code>&lt;device_var&gt;:read_registers(REG, &lt;int&gt;)</code> syntax can be used. With the above example: <pre><code>sensor:read_registers(REG, 2)\n</code></pre> will read two bytes of data, starting from sensor\u2019s register with address <code>REG</code>.</p> <p>The data read from the registers will come in the shape of an array of bites and need to be broken up into separate binary integers. This is done differently depending on the device\u2019s endianness which must be found from the documentation. Figure 2 helps show the difference between little- and big-endian systems. This only changes the order of the bites transferred but must accounted for to get the data accurately.</p> <p></p> <p>Endianness in a two-byte system. Image credit: https://www.allaboutcircuits.com/technical-articles/big-endian-little-endian-endianness-byte-arrangement-digital-systems/ </p> <p>The example code I2C.lua will showcase the basic bit operations that will help extract the data from the bit array the data was transmitted in in both big- and little-endian systems. </p>"},{"location":"Avionics/Mission-Planner/","title":"Mission Planner","text":"<p>Mission planner is the software used to communicate and control the cube. Your code should replace Mission Planner and provide the same basic functionality. Mission planner is still useful to use for testing and has numerous vital features.</p> <p>Installation info (ardupilot.org)</p> <p>Mission Planner overview (ardupilot.org)</p>"},{"location":"Avionics/Mission-Planner/#connecting","title":"Connecting","text":"<p>Mission Planner can be connected to the Cube over Wifi and USB. If connecting through USB, make sure to use the buzzer; do not plug the cable directly into the Cube. In mission planner, on the top right of the window, you will see two selection boxes and a <code>Connect</code> button. If you know which <code>COM</code> terminal you plugged the USB into, select it, but there is an <code>AUTO</code> function too. </p> <p>Wait until the cube buzzes before clicking connect.</p> <p></p> <p>Image credit: Mission Planner</p> <p>Using the Wifi module is a bit different but simple. After setting up the Wifi chip (for more information see Wifi), connect the chip to the Cube\u2019s <code>Telem1/Telem2</code> port and your computer to the Wifi network. Select the <code>UDP</code> setting and hit connect.</p> <p>If not working, make sure you're still connected to the chip (and not Eduroam) and your GCS isn't connected to the cube</p>"},{"location":"Avionics/Mission-Planner/#parameters","title":"Parameters","text":"<p>When first connecting to the cube, there are a few parameters that need changing. In Mission Planner, a parameter is a configurable setting that tells the flight controller (like the Cube) how to behave. Parameters control everything from flight modes, sensor settings, failsafes, and PID tuning, to things like which servo does what and how fast a drone should climb or descend.</p> <p>To access parameters, go to config and then full parameter list. This opens up every single parameters available for you to change. Scroll or search for <code>NFT_BUZZ_VOLUME</code> and turn it down so the cube doesn\u2019t scream at you every time you turn it on. Then click <code>write params</code> and congratulations you\u2019ve changed the cube settings. </p> <p></p> <p>Don\u2019t forget to save your parameters every so often so you don\u2019t lose them.</p> <p>Uselful Parameters:</p> Parameter Value Meaning <code>NTF_BUZZ_VOLUME</code> 1\u20135 Sets buzzer volume level <code>ARMING_CHECK</code> 0 Disables all arming checks <code>ARMING_REQUIRE</code> 0 Disables requirement for arming <code>THR_FAILSAFE</code> 2 Enables throttle failsafe in land mode. <code>FLIGHTMODE_CH</code> 5 RC channel used to switch flight modes (usually RC5). <code>FLTMODE1</code> 0 Flight mode 1 = Stabilize mode. <code>FLTMODE6</code> 10 Flight mode 6 = Auto mode. <code>RC6_OPTION</code> 4 RC6 triggers Arm/Disarm. <code>RC7_OPTION</code> 31 RC7 triggers <code>Mission Start</code>. <code>RC8_OPTION</code> 208 RC8 triggers <code>Relay Toggle</code> (custom or user-defined action). <code>TERRAIN_FOLLOW</code> 0 Terrain following disabled during missions. <code>TERRAIN_ENABLE</code> 0 Terrain data not used (no elevation mapping). <code>SERIAL1_PROTOCOL</code> 2 MAVLink protocol enabled on SERIAL1. <code>SERIAL1_BAUD</code> 921 Baud rate set to 921600 <p>Default Channel Order:</p> Function Channel Port Aileron 1 Main Elevator 2 Main Throttle 3 Main Rudder 4 Main <p>Flap Control:</p> Parameter Value Meaning <code>SERVO5_OPTION</code> 0 / 2 0 = PyMAVLink control, 2 = RC Control <code>SERVO5_MAX</code> CALC Maximum PWM output for SERVO5. <code>SERVO5_MIN</code> CALC Minimum PWM output for SERVO5. <code>SERVO5_TRIM</code> CALC Neutral (center) PWM value for SERVO5. <p>Aileron Control:</p> Parameter Value Meaning <code>SERVO1_OPTION</code> 4 RC passthrough or assigned aileron output. <code>SERVO1_MAX</code> CALC Maximum PWM signal. <code>SERVO1_MIN</code> CALC Minimum PWM signal. <code>SERVO1_TRIM</code> CALC Neutral PWM value. <p>Elevator Control:</p> Parameter Value Meaning <code>SERVO2_OPTION</code> 0 / 19 0 = PyMAVLink control, 19 = RC Control <code>SERVO2_MAX</code> CALC Maximum PWM signal. <code>SERVO2_MIN</code> CALC Minimum PWM signal. <code>SERVO2_TRIM</code> CALC Neutral PWM value. <p>Rudder Control:</p> Parameter Value Meaning <code>SERVO4_OPTION</code> 21 Assigned rudder control output. <code>SERVO4_MAX</code> CALC Maximum PWM value. <code>SERVO4_MIN</code> CALC Minimum PWM value. <code>SERVO4_TRIM</code> CALC Neutral PWM value."},{"location":"Avionics/Mission-Planner/#servo-actions","title":"Servo Actions","text":"<p><code>Ctrl F</code> opens up some a settings menu. Click <code>toggle servo safety</code> as seen below to turn off the safety. </p> <p></p> <p>In <code>Actions</code> there\u2019s the arm button as seen below. This panel also allows you to manually set the flight mode.</p> <p></p> <p>The <code>Servo/Relay</code> panel allows you to manually move servos in Mission Planner.</p> <p></p> <p>Make sure safety toggle is off or you won't be able to move anything</p> <p>You'll also need to have set up the parameters for the servo you want to move</p>"},{"location":"Avionics/PyMavlink/","title":"PyMAVLink","text":"<p>The cube uses MAVLink, a lightweight communication protocol to receive commands and transmit data to and from the Ground Station. Python has a MAVLink module called Pymavlink that will allow to send and capture MAVLink messages.</p> <p>To be able to do so, first the code must connect to the Cube through MAVLink (see Cube Information for how to physically connect to the Cube). An example code will be provided to show a baseline for how to connect to the flight controller with python. (See GS.py)</p> <p>Make sure to disconnect from Mission Planner before connecting through PyMAVLink, otherwise it won't work.</p> <p>Another example code will show how to send commands over MAVLink (in particular, arming the Cube see Arm.py). Use this to develop your code.</p> <p>Sending Commands using MAVLINK: Use the <code>command_long_send</code> function of the mavlink library to send control demands to the cube.</p> <p>This command takes 7 parameters:  <pre><code>(target_system, target_component, command, confirmation, param1 - 7)\n</code></pre></p> <p>pyMAVLINK \u201cmodule not found\u201d error</p> <p>Run <code>pip --upgrade --force-reinstall pymavlink</code> in an administrator command prompt</p>"},{"location":"Avionics/RC/","title":"RC","text":"<p>Your Radio Control System will be centered ariound the Taranis X9 Lite. It uses the OpenTX firmware and will allow you to control the flight surfaces and relinquish control to your GCS.</p> <p></p> <p>Controller Manual (frsky-rc.com)</p> <p>The Controller communicates to the cube using the trasmitter.</p> <p>IMAGE OF TRANSMITTER</p>"},{"location":"Avionics/RC/#set-up-transmitter","title":"Set up Transmitter","text":"<p>To connect the Transmitter to your controller you need to click the button then the other button.</p> <p>Hold until it connects and blinks light and tada connected.</p>"},{"location":"Avionics/RC/#set-up-channels","title":"Set up Channels","text":"<p>First step once connected is calibrating the controller. Use the Radio Control Calbration guide (ardupilot.org)</p> <p>Next define your RC channels on the Controller. Click Click CLick and then choose number</p> <p>Next define the channels to functions using parameters. This can be done in Mission planner or through your code.</p>"},{"location":"Avionics/Wifi/","title":"Wifi","text":"<p>The Adafruit HUZZAH ESP8266 is a compact Wi-Fi microcontroller module based on the ESP8266 chip, ideal for IoT projects. It features built-in Wi-Fi, GPIO pins, and supports programming via Arduino or Lua. It can be configured to communicate with the Cube flight controller over Wi-Fi, enabling wireless telemetry, MAVLink communication, and remote parameter tuning.</p> <p>How to set up the Wifi chip: ESP8266 Ardupilot guide (ardupilot.org)</p> <p>You shouldn't need to flash the chip, just set a name and password</p> <p>Wifi chip documentation: Adafruit HUZZAH ESP8266 breakout doc (adafruit.com)</p> <p>Going to need to update this all for the new wifi protocols.</p>"},{"location":"Avionics/pressure/","title":"Page 1","text":"<p>School of Civil, Aerospace, and Design Engineering AENG20007 AVDASI 2 2023-2024 PRESSURE ACQUISITION SYSTEM: GUIDANCE FOR STUDENTS Version Number: 1.0 Author: S. Reid Version Date: 16/01/2024 Version Date Modifications Modified By 1.0 16/01/2024 Initial Document Release Sid Reid 1 General Overview The wind tunnel testing component of the AVDASI 2 module allows you to collect experimental data from your UAV. Pressure data from around the surface of a wing can be useful for validating predicted aerodynamic performance data. The AVDASI 2 module requires you to implement a pressure acquisition system, conisting of 12 individual sensors, to record the dynamic pressure on the surfaces of your UAV. This document will provide guidance for setting the pressure system up, and should be used as a supplement to the content provided in lectures. The pressure acquisition system requires each team to: \u2022 Decide the ideal/best location for each sensor - Where does it make sense to put them? Where could you benefit from more sensors? What considerations should be made to allow accurate readings? \u2022 Design new components and methods for mounting the pressure acquisition system securely - How do you ensure the system is secure in advance of wind tunnel testing? Are there any space constraints which limit where pressure sensors can be located? Have you considered how cables/tubing will be routed within the UAV? \u2022 Expand on the baseline data collection software as desired - What additional features are re- quired? How can you log the data in a way which matches the order/methodology of the test? \u2022 Ensure all components are in a condition to be returned following wind tunnel testing - What non- permanent methods for labelling sensors and boards can you come up with? Is your mounting solution for the system likely to cause damage to the boards? 2 Kit List Component Quantity Comments Pressure Reading Board 4 Provided Microcontroller Acquisition Shield 1 Provided Arduino Micro 1 Provided Micro USB Cable 1</p> <p>3m - Provided Connection Wires 4 x 5 Custom Lengths Tubes - Sensor Dynamic Port 12 Custom Lengths Tubes - Sensor Reference Port 12 Custom Lengths Tubes - Manifold 1 3m - Provided Brass Tube Reinforcement 12 1 per Tube Manifold - Reference Pressure 1 Provided Page 1 of 7 and test plan v2 hacked about by Steve maybe reissued when I can get his LaTeX!</p> <p></p>"},{"location":"Avionics/pressure/#page-2","title":"Page 2","text":"<p>Aeng20007 AVDASI2 - Group Design, Build, and Test 3 System Overview The AVDASI 2 pressure acquisition system is a bespoke system consisting of 4 sensor boards, each board has 3 pressure differential readings (total of 12 pressure differential readings), 1 microcontroller shield board, and an Arduino Micro microcontroller. This system uses the Arduino Micro to log the analogue readings from each pressure sensor and interfaces with a MATLAB-based UI for data collection and processing. The data is logged at 50Hz and is processed from raw analogue voltage readings to pressure readings (in Pascals) within the MATLAB script. Pressure Acquisition Board Pressure  Sensor Pressure  Sensor Pressure  Sensor Screw Terminal Block To: Reference Manifold From: Surface Points Main Shield Screw Terminal Block Screw Terminal Block Screw Terminal Block Screw Terminal Block POWER &amp; DATA Connection USB to PC X 4 Figure 3.1: Diagram showing an overview of the AVDASI 2 pressure system Figure 3.1 shows an overview of the entire pressure acquisition system. The 12 Pressure sensors have a total of 24 input ports for silicone tubing. 12 should be connected to their respective sensing points on the surface and 12 are attached to the pressure manifold. This manifold has a single output which must be connected to a long \u201dexit tube\u201d. 4 Connections Required 4.1 Electrical Connections Each of the pressure reading boards has a screw terminal block capable of connecting 5 wires. The configuration of these blocks is the same for every one of the boards. When looking at the in-port side of the block, the pinout is: [P1] [P2] [P3] [5V] [GND]. The MPXV7002DP Pressure Sensors are labelled similarly. Each of these ports must be connected to the corresponding port on the Microcontroller shield, as shown in Table 4.1. Only one connection in each port is required for each board. Table 4.1: Showing connections between pressure reading board and microcontroller shield. Pressure Reading Board Microcontroller Shield P1 P1, P4, P7, P10 P2 P2, P5, P8, P11 P3 P3, P6, P9, P12 5V 5V GND GND The microcontroller shield then connects to the Arduino Micro, using pins A0 to A11 to read all 12 analogue inputs. There is a green LED next to each pressure sensor indicating that the sensor is Page 2 of 7</p> <p></p>"},{"location":"Avionics/pressure/#page-3","title":"Page 3","text":"<p>Aeng20007 AVDASI2 - Group Design, Build, and Test powered correctly. The Arduino micro should be connected to the shield such that the usb port aligns with the box at the top of the rectangular footprint on the PCB. 4.1.1 Troubleshooting When troubleshooting the connections to the board it is recommended to first use a multi-meter to perform a \u201dcontinuity check\u201d between each of the boards. To do this use the probes of the multi-meter on the screw heads in the terminal blocks. This check will allow the simplest issues to be ruled out before seeking help from a Postgraduate or Staff member. There are some spare boards available but these will be used on a first-come-first-served basis. 4.2 Pressure Connections The pressure connections in the AVDASI pressure acquisition system are all designed for use with 2mm Inner Diameter silicone tubing. The MPXV7002DP sensor has two ports, the upper port measures the dynamic pressure and the lower port should be connected to the reference pressure. The sensor records the difference in pressure between the dynamic and reference pressure and outputs this as an analogue voltage. 4.2.1 Manifold The 12-to-1 pressure manifold is the first pressure connection to consider within the wing and fuselage. Setup of this manifold involves connecting the 12 reference pressure ports on each pressure sensor to an input of the manifold. The pressure manifold must be airtight to avoid fluctuations in the reference pressure reading caused by the wind tunnel. Figure 4.1 shows the 12 input ports and the single output port of the manifold. 12 x \u00d8 4mm 19 \u00d86 4 33 76 2.5 30 Figure 4.1: Figure showing a dimensioned drawing of the reference pressure manifold The single output port must be connected to a silicone tube with an overall length greater than 3m. This output tube must then be routed through the tip of the wing, or the back of the fuselage pod. To ensure that the pressure manifold remains airtight it has been covered with epoxy resin. The tubes you add to the inputs should therefore also be epoxied in place. To test whether the pressure Page 3 of 7</p> <p></p>"},{"location":"Avionics/pressure/#page-4","title":"Page 4","text":"<p>Aeng20007 AVDASI2 - Group Design, Build, and Test manifold is airtight, it is advised to submerged the manifold in water (with all of the tube ends above the surface) and check for bubbles. The presence of bubbles indicates that the manifold is not airtight - and thus needs to have more epoxy resin applied. 4.2.2 Wing Surface As explained in the Week 14 wind tunnel lecture (2 of 2), any bumps or excessive surface roughness will have a significant impact on the boundary layer development on both the wings and fuselage, which will ultimately influence the surface pressure data and your pressure distribution. Thus, it is critical that the pressure sensor inlet is flush with the surface. To help you achieve this, we will provide brass tube inserts (see Figs. 4.2 and 4.3) that are to be slotted within the tubes. Figure 4.2: Figure showing an example of how the surface should be finished using the brass tube inserts \u00d84 \u00d82 14 0.2 0.2 R0.8 Figure 4.3: Figure showing the dimesnions of the brass tube inserts Precise positioning of the sensor locations on the surface of the wing and fuselage is essential for producing a complete profile of the pressures over the entire surface. For this reason, determining the best/most interesting flow locations is necessary. This section will primarily repeat the information given in the lecture slides. For measuring the pressure distribution over an aerofoil equispaced and symmetrical configurations of pressure sensors will not give the best coverage or description of the flow field. To achieve the best coverage using the pressure sensors, the rate of change of surface gradient should be considered. So that sufaces with the highest rate of change have the largest number of sensors. XFLR5 and XFOIL can also be used to help determine the best pressure sensor locations. Figure 4.4 shows a plot of the coefficient of pressure across the surface of an aerofoil. It is important when considering the optimum locations to consider this distribution. A higher number of sensors should be placed around areas of the polar with the greatest change observable. You may find that you want to put at least one sensor in flap of your wing. In this case you must consider how to prevent the tube connecting to the surface from stretching or being pinch during the Page 4 of 7</p> <p></p>"},{"location":"Avionics/pressure/#page-5","title":"Page 5","text":"<p>Aeng20007 AVDASI2 - Group Design, Build, and Test Figure 4.4: Graph of the Coefficient of Pressure Polar across the aerofoil flap\u2019s motion. Any stretching or pinching will restrict the tube\u2019s flow and will result in poor accuracy from the pressure readings. Once you have decided on the 12 best locations for the pressure sensors these must be stored in an excel document in the format shown in Table 4.2. This file must be brought with you on the day of wind tunnel testing. Table 4.2: Table showing the format for the excel file containing the pressure sensor locations Sensor Number x y x/C P1 xx.xx yy.yy</p>"},{"location":"Avionics/pressure/#_1","title":".","text":"<p>P2 : : : P3 : : : P4 : : : P5 : : : P6 : : : P7 : : : P8 : : : P9 : : : P10 : : : P11 : : : P12 : : : 4.2.3 Sensor Each of the sensors on the pressure acquisition boards has 2 ports. The upper port should be connected to the surface at the point at which you want to record pressure readings. The lower port should first be connected to the pressure manifold, and then out through the tip of the wing (as described in Section 4.2.1. Figure 4.5 shows a diagram of the port configuration of the MPXV7002DP Sensor. The pressure sensor operates by reading the differential pressure between the two ports. This differen- tial pressure is then output as a voltage between 0.5V and 4.5V, The analogue voltage is read by the Arduino Micro and is passed through a transfer function to convert from voltage to pressure. More information on the pressure sensor and its operation can be found at: Datasheet. 5 Software The Arduino Micro has a simple code running on it which takes 10 readings from the pressure sensors on boot and calculates the average for each sensor. This allows each sensor to have a custom zero Page 5 of 7</p> <p></p>"},{"location":"Avionics/pressure/#page-6","title":"Page 6","text":"<p>Aeng20007 AVDASI2 - Group Design, Build, and Test Dynamic Pressure Input Reference Pressure Input Figure 4.5: Illustration of the port configuration of the MPXV7002DP sensor (looking directly at the side with ports) offset. The code then takes a reading from each sensor in turn at a rate of 50Hz. These are output to the MATLAB app. The app is shown in Figure 5.1. Figure 5.1: Screenshot of Version 1 of the MATLAB App The MATLAB app then takes these readings and applies a transfer function to them, This converts the analogue signal into a pressure reading in Pascals. The data is saved in a .CSV file and can be processed to give the coefficient of pressure at each point on the surface of the wing. Any modifications to the MATLAB app are welcome - however, these modifications must be tested fully prior to wind tunnel testing, to ensure that there is no loss of experimental data. 6 Gate submission The requirements for the gate submission document are as follows: 1. Complete Table 4.2. 2. Why did you chose these locations? Wing Teams: Did you focus on the wing pressure or suction surface or both? POD/fuselage teams: Did you focus on the port or starboard surface or both? Include in your explanations references to XFOIL-obtained or relevant published data and material covered in the lecture slides. You may wish to include a diagram to support your answers. (short paragraph) 3. Will any of the sensors be placed at different spanwise locations (for wing teams) or waterlines (for fuselage/pod teams)? In any case, explain why, and refer back to the relevant lecture slides. (maximum of two sentences). 4. What are any possible foreseeable issues with your sensor arrangement? (maximum of two sentences). Page 6 of 7 Test Plan</p> <p></p>"},{"location":"Avionics/pressure/#page-7","title":"Page 7","text":"<p>Aeng20007 AVDASI2 - Group Design, Build, and Test 5. POD/fuselage teams: your experiments will be conducted at a single flow speed, U0, which will be determined on the day of testing based on the structural resilience of the design with increasing flow speed. During static tests, three yaw angles will be tested, being 0\u25e6, 1\u25e6and 2\u25e6 and seven pitch angles (\u221210\u25e6to +20\u25e6in 5\u25e6increments). Create a Test Matrix (as introduced in Week 14 Lecture 2 of 2) to summarise this experimental regime. Note that the dynamic tests will be dependent on the outcome of the static tests and you are not expected to develop a test matrix for these cases. 6. Wing Teams: your experiments will be conducted at two flow speeds, U0,1 and U0,2; the maximum value will be determined on the day of testing based on the structural resilience of the design with increasing flow speed. Up to ten angles of attack will be tested, from 0\u25e6to approaching stall in no less than 1\u25e6increments, at positive and negative angles of attack. In each case, the flap will be tested in up, down and in neutral positions. The aileron will be tested for maximum and minimum deflection for each case. Create a Test Matrix (as introduced in Week 14 Lecture 2 of 2) to summarise this experimental regime. 7. Provide an estimate of the number of total experimental stages outlined. Discuss the overall balance of total number of experimental stages, including whether each stage is necessary to develop the experimentally required outputs (such as drag coefficient, etc). (maximum of three sentences) Page 7 of 7</p> <p></p>"},{"location":"Structures/","title":"Structures","text":"<p>Example homepage</p>"}]}